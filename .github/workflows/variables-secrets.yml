 name: Explorando variables y secretos
 on: 
    ## Sirve para ejecutar manualmente el workflow
    workflow_dispatch:
    ## sirve para un temporizador
    #schedule:
     # - cron: "*/1 * * * *"
     #push

 env:
    CONTAINER_REGISTRY: docker.io
    IMAGE_NAME: github-actions-nginx
 jobs:
    docker:
        runs-on: ubuntu-latest
        steps:
        - name: Docker build
          run: echo docker build -t ${{ env.CONTAINER_REGISTRY }}/${{ vars.DOCKER_USERNAME }}/$IMAGE_NAME:latest
        - name: Docker login
          run: echo docker login --username=${{ vars.DOCKER_USERNAME }} --password=${{ secrets.DOCKER_PASSWORD }}
        - name: Docker publish
          run: echo docker push $CONTAINER_REGISTRY/${{ vars.DOCKER_USERNAME }}/$IMAGE_NAME:latest
    deploy:
      needs: docker
      ## usamos la propiedad concurrency con Evitar ejecuciones duplicadas
      ## Unos de los job demoraba 20 minutos por ejemplo un deploy.. Dos desarrolladores hacieron
      ## push casi al mismo tiempo y se dispararon dos despliegues en paralelo en el worflow
      ##  que pasaria? se duplicada la ejecuccion y para la duplicacion utilizamos concurrency
      concurrency:
        group: production-deployment
        cancel-in-progress: false  #false es cuando se queda en espera hasta que termine el otro y 
        # el true es cuando cancela el job anterior y ejecuta el actual
      runs-on: ubuntu-latest
      steps:
        - name: Docker run
        ## utilizamos timeout minutes para que si el job demora mas de 10h lo cancele en 1 minuto.
          timeout-minutes: 1
          run: |
            echo docker run -d -p 8080:80 $CONTAINER_REGISTRY/${{ vars.DOCKER_USERNAME }}/$IMAGE_NAME:latest
            sleep 6000s

